\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{textcomp}
\usepackage{a4wide}
\usepackage{tabu}
\usepackage{amsmath, amssymb}
\usepackage{array}
\usepackage{listings}
\usepackage{caption,subcaption}


\lstset{
language=Python,
basicstyle=\ttfamily\small,
otherkeywords={self},                   
}

\title{Title}
\title{Стохастическая оптимизация. Метод SAG.}
\date{4 октября 2015}
\author{Павел Измаилов}

\begin{document}

\renewcommand{\contentsname}{\centerline{\bf Содержание}} %!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

\renewcommand{\refname}{\centerline{\bf Список литературы}}

\newlength{\arrayrulewidthOriginal}
\newcommand{\Cline}[2]{%
  \noalign{\global\setlength{\arrayrulewidthOriginal}{\arrayrulewidth}}%
  \noalign{\global\setlength{\arrayrulewidth}{#1}}\cline{#2}%
  \noalign{\global\setlength{\arrayrulewidth}{\arrayrulewidthOriginal}}}

%\maketitle
\centerline{Московский государственный университет им. М. В. Ломоносова}

\centerline{Факультет вычислительной математики и кибернетики}

\vspace{5 cm}

\centerline{\Large Отчет}

\vspace{1 cm}

\centerline{\Large \bf По заданию №1}
\centerline{\Large \bf по практикуму на ЭВМ}

\vspace{6 cm}

\begin{flushright} 
Выполнил студент 317 группы

Измаилов Павел Алексеевич
\end{flushright}

\vfill 

\centerline{Москва,  9 октября 2015}
\thispagestyle{empty} 
\pagebreak

\section{Описание проделанной работы}

В данном отчете содержатся результаты экспериментов, проведенных мной в соответствии с первым заданием по курсу практикума на ЭВМ на кафедре ММП ВМК МГУ. Задание не содержало творческой или теоретической части. Все необходимые эксперименты были проведены, и по ним были получены соответствующие выводы.

Для каждой задачи мной было реализовано три варианта решения — полностью векторизованный, полностью не векторизованный и написанный в стиле функционального программирования. 

Весь код был написан мной в соответствии с набором правил PEP 8. Для каждой задачи были написаны автоматические тесты, проверяющие совпадение результатов работы всех вариантов кода.
\pagebreak
\section{Эксперименты}

	\hspace{0.6cm}В данном разделе описываются задачи, рассматриваемые в работе, их решения, проведенные эксперименты и полученные результаты. 
	
	Для каждого решения среднее время работы оценивалось с помощью команды \lstinline$%timeit -n 1000$, кроме случаев, когда это оговорено отдельно.

\subsection{Задача 1}

	\hspace{0.6cm}В первой задаче требовалось вычислить произведение ненулевых элементов, стоящих на диагонали прямоугольной матрицы $M \in \mathbb{R}^{n \times m}$. 
	
	В невекторизованное решении данной задачи произведение ненулевых диагональных элементов вычисляется в цикле по всем диагональным элементам. В векторизованном решении для выделения ненулевых диагональных элементов используется {\it слайсинг}, после чего они перемножаются с помощью функции \lstinline$numpy.prod()$. В функциональном решении с помощью {\it list comprehension} строится список \lstinline$lst$ всех диагональных элементов, и его ненулевые элементы перемножаются с помощью функции \lstinline$reduce((lambda a, b: a*b + a*int(a*b == 0), lst, 1)$.
	
	Для данной задачи было проведено три эксперимента для случайных матриц $M$ разных размеров, у которых четверть диагональных элементов равна 0. Результаты экспериментов приведены в таблице \ref{prb_1}.
	\begin{table}[h]
		\begin{center}
		\begin{tabular}{| c | c !{\vrule width 1.2pt}  c| c | c |}
		\hline
			\multicolumn{2}{ | c  !{\vrule width 1.2pt}  }{Параметры задачи}&
			\multicolumn{3}{   c |  }{Время работы}\\
			\hline
			$n$ 
			& 
			$m$ 
			& 
			\begin{tabular}{c} 
			Невект.\\
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$100$ & $30$ &18 $\mu$s& 13.6 $\mu$s & 37.9 $\mu$s\\
			\hline 
			$1000$ & $1000$ & 523 $\mu$s& 32 $\mu$s &1.12 ms\\
			\hline 
			$5000$ & $7000$ & 2.45 ms & 128 $\mu$s & 5.89 ms\\
			\hline
		\end{tabular}
		\end{center}

		\caption{Результаты экспериментов по первой задаче}
		\label{prb_1}
	\end{table}

\subsection{Задача 2}

	\hspace{0.6cm}Во второй задаче требовалось построить вектор из элементов матрицы  $M \in \mathbb{R}^{n \times m}$, координаты которого — соответствующие элементы двух векторов равной длины \linebreak$i, j~\in~\mathbb{R}^l$. 
	
	Невекторизованное решение в цикле строит список всех требуемых элементов матрицы. Векторизованное решение строит необходимую подматрицу с помощью {\it слайсинга}. Функциональное решение строит список требуемых элементов с помощью {\it list comprehension}.
	
	Для этой задачи было проведено три эксперимента для случайных матриц $M$ разных размеров и векторов $i$ и $j$ с различными длинами $l$. Результаты экспериментов приведены в таблице \ref{prb_2}.

	\begin{table}[t]
		\begin{center}
		\begin{tabular}{| c | c | c !{\vrule width 1.2pt} c | c | c |}
			\hline
			\multicolumn{3}{ |c!{\vrule width 1.2pt} }{Параметры задачи}&
			\multicolumn{3}{ c| }{Время работы}\\
			\hline
			$n$ & $m$ & $l$ &\begin{tabular}{c} 
			Невект.\\ 
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$100$ & $30$ & $15$ &14.7 $\mu$s& 2.41 $\mu$s & 14.9 $\mu$s\\
			\hline 
			$1000$ & $1000$ & $700$ & 403 $\mu$s& 9.4 $\mu$s & 319 $\mu$s\\
			\hline 
			$5000$ & $7000$ & $2000$ & 1.14 ms & 41.8 $\mu$s & 900 $\mu$s\\
			\hline
		\end{tabular}
		\end{center}
		\caption{Результаты экспериментов по второй задаче}
		\label{prb_2}
	\end{table}

\subsection{Задача 3}

	\hspace{0.6cm}В этой задаче требовалось проверить, совпадают ли мультимножества \lstinline$mul(i)$ и \lstinline$mul(j)$, заданные данными векторами $i, j \in \mathbb{R}^l$. 
	
	Все решения основываются на сортировке данных векторов. Невекторизованное решение сортирует списки из элементов векторов с помощью функции \lstinline$sorted$, после чего последовательно сравнивает получившиеся списки в цикле. Векторизованное решение использует функцию сортировки векторов \lstinline$numpy.sort()$, после чего сравнивает отсортированные вектора с помощью \lstinline$numpy.all()$. Функциональное решение сравнивает отсортированные с помощью \lstinline$sorted()$ списки элементов векторов с помощью функции \lstinline$reduce()$.
	
	Для этой задачи было проведено шесть экспериментов: по три эксперимента с разными $l$  для векторов, задающих одинаковое и разное мультимножество.  В случае одинакового мультимножества генерировался случайный вектор $v$ заданной длины, после чего вектора $i$ и $j$ получались случайным перетасовыванием его элементов. В случае, когда генерировались разные мультимножества, вектора $i$ и $j$ были взяты случайными. В таблице \ref{prb_3} приведены результаты работы алгоритмов. 

	\begin{table}[h]
		\begin{center}
		\begin{tabular}{| c | c  !{\vrule width 1.2pt} c | c | c |}
			\hline
			\multicolumn{2}{ | c  !{\vrule width 1.2pt}  }{Параметры задачи}&
			\multicolumn{3}{   c |  }{Время работы}\\
			\hline
			$l$ & \lstinline$mul(i) == mul(j)$
			&
			\begin{tabular}{c} 
			Невект.\\
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$30$ & True & 20.1 $\mu$s& 17 $\mu$s & 31.2 $\mu$s\\
			\hline 
			$30$ & False & 18.7 $\mu$s& 16.5 $\mu$s & 31.2 $\mu$s\\
			\hline 
			$1000$ & True & 788 $\mu$s&  87.6 $\mu$s & 842 $\mu$s\\
			\hline 
			$1000$ & False & 707 $\mu$s& 86.2 $\mu$s & 825 $\mu$s\\
			\hline 
			$10000$ & True& 9.36 ms & 1.08 ms & 10.6 ms\\
			\hline
			$10000$ & False & 8.56 ms & 1.11 ms & 11 ms\\
			\hline
		\end{tabular}
		\end{center}
		\caption{Результаты экспериментов по третьей задаче}
		\label{prb_3}
	\end{table}
	
	\subsection{Задача 4}
	
	\hspace{0.6cm}В этой задаче требовалось найти максимальный элемент в векторе $x \in \mathbb{R}^l$, среди элементов, перед которыми в $x$ стоит $0$. 
	
	В невекторизованном решении элементы вектора последовательно просматриваются в цикле, и среди элементов, стоящие после $0$ выбирается максимум. Векторизованное решение приведено в листинге \ref{lst_vec_4}. В функциональном решении список элементов, стоящих в векторе после нулей, строится с помощью {\it list comprehension}, после чего в нем ищется максимум с помощью функции \lstinline$max()$.
	
	\begin{lstlisting}[frame=lines, caption={Векторизованное решение задачи 4}, label=lst_vec_4]
def vec_maximum_in_front_of_zero(vec):
    return np.max((np.roll(vec, -1))[vec[:-1] == 0])	
	\end{lstlisting}
	
	Для этой задачи было проведено три эксперемента для различных $l$. Для каждого эксперемента был сгенерирован случайный вектор $x$, после чего в него было добавлено некоторое количество нулей. Результаты экспериментов приведены в таблице \ref{prb_4}.
	
	\begin{table}[h]
		\begin{center}
		\begin{tabular}{| c  !{\vrule width 1.2pt} c | c | c |}
			\hline
			\multicolumn{1}{ | c  !{\vrule width 1.2pt}  }{Параметры задачи}&
			\multicolumn{3}{   c |  }{Время работы}\\
			\hline
			$l$
			&
			\begin{tabular}{c} 
			Невект.\\
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$30$ & 9.22 $\mu$s& 20.5 $\mu$s & 14.2 $\mu$s\\
			\hline 
			$1000$ & 222 $\mu$s&  27.9 $\mu$s & 295 $\mu$s\\
			\hline 
			$10000$ & 2.3 ms & 99 $\mu$s & 2.94 ms\\
			\hline
		\end{tabular}
		\end{center}
		\caption{Результаты экспериментов по четвертой задаче}
		\label{prb_4}
	\end{table}

\subsection{Задача 5}
	
	\hspace{0.6cm}В данной задаче требовалось написать функцию, складывающую каналы данного изображения в формате \lstinline$png$ с заданными весами. 
	
	В невекторизованном решении результат вычисляется в цикле, как сумма матриц с заданными весами (суммирование матриц также производится в цикле). В векторизованном решении результат вычисляется с помощью функции \lstinline$numpy.average()$. В функциональном решении результат получается с помощью функции \lstinline$reduce$ для списка из кортежей, составленных из весов и каналов изображения.
	
	Для этой задачи было проведено три эксперимента с картинками разных размеров $(m, n)$. Каждый эксперимент для первых двух картинок (меньших размеров) был повторен $100$ раз для векторизованного и функционального решения, и $10$ раз для невекторизованного. Для самой большой картинки векторизованное и функциональное решения запускались по $10$ раз, а невекторизованное — $2$ раза, после чего результаты усреднялись. Результаты экспериментов приведены в таблице \ref{prb_5}.
	
	\begin{table}[t]
		\begin{center}
		\begin{tabular}{| c | c   !{\vrule width 1.2pt} c | c | c |}
			\hline
			\multicolumn{2}{ | c  !{\vrule width 1.2pt}  }{Параметры задачи}&
			\multicolumn{3}{   c |  }{Время работы}\\
			\hline
			$m $ & $n$
			&
			\begin{tabular}{c} 
			Невект.\\
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$481$ & $209$ & 343 ms&  9.95 ms & 3.21 ms\\
			\hline 
			$960$ & $804$ & 1.41 s & 39.9 ms & 10.9 ms\\
			\hline 
			$1800$ & $2880$ & 8.57 s & 274 ms & 78.1 ms\\
			\hline
		\end{tabular}
		\end{center}
		\caption{Результаты экспериментов по пятой задаче}
		\label{prb_5}
	\end{table}
	
\subsection{Задача 6}
	\hspace{0.5cm}В этой задаче требовалось реализовать кодирование длин серий для данного вектора $v \in \mathbb{R}^l$. 
	
	В невекторизованном решении списки элементов кодирующих векторов генерируются в цикле по всем элементам данного вектора. Векторизованное решение приведено в листинге \ref{lst_vec_6}. Функциональное решение приведено в листинге \ref{lst_fun_6}.
	
	\begin{lstlisting}[frame = lines, caption={Векторизованное решение задачи 6}, label=lst_vec_6]
def vec_run_length_encoding(vector):
    vec = vector + 1
    elems = vec[np.roll(vec, 1) != vec]
    if (elems.size == 0):
        return np.array([vec[0] - 1]), np.array([vec.size])
    reverse_cumsum = (np.cumsum(vec[::-1]))[::-1]
    elem_reverse_cumsum = reverse_cumsum[np.roll(vec, 1) != vec]
    denom = np.copy(elems)
    denom[elems == 0] = 1
    elem_count = (elem_reverse_cumsum -
                  np.hstack((np.roll(elem_reverse_cumsum, -1)[:-1], 
                  0))) / denom
    return elems-1, elem_count.astype(int)
	\end{lstlisting}

	Для данной задачи было проведено три эксперимента для различных $l$. Результаты экспериментов приведены в таблице \ref{prb_6}.
	
	\begin{table}[h]
		\begin{center}
		\begin{tabular}{| c  !{\vrule width 1.2pt} c | c | c |}
			\hline
			\multicolumn{1}{ | c  !{\vrule width 1.2pt}  }{Параметры задачи}&
			\multicolumn{3}{   c |  }{Время работы}\\
			\hline
			$l$
			&
			\begin{tabular}{c} 
			Невект.\\
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$30$ & 20.4 $\mu$s& 70 $\mu$s & 58.5 $\mu$s\\
			\hline 
			$1000$ & 518 $\mu$s&  105 $\mu$s & 1.53 ms\\
			\hline 
			$10000$ & 5.34 ms & 366 $\mu$s & 16.4 ms\\
			\hline
		\end{tabular}
		\end{center}
		\caption{Результаты экспериментов по шестой задаче}
		\label{prb_6}
	\end{table}
	\pagebreak
	
	\pagebreak
	\begin{lstlisting}[frame = lines, caption={Функциональное решение задачи 6}, label=lst_fun_6]
def fun_run_length_encoding(vec):
    def fun(i, elem):
        if (i >= len(vec)) or (vec[i] != elem):
            return 0
        return 1 + fun(i + 1, elem)

    elems = np.array([vec[0]] + [elem for elem, prev in
                                 list(zip(vec[1:], vec[:-1])) 
                                 if elem != prev])
    indices = [0] + [i for i in range(1, len(vec))
                     if vec[i] != vec[i-1]]
    return (elems,
            np.array([fun(i, elem) for i, elem in 
                      list(zip(indices, elems))]))
	\end{lstlisting}
	

\subsection{Задача 7}

\hspace{0.5cm}В этой задаче требовалось вычислить матрицу попарных евклидовых расстояний между строкамми матриц $X \in \mathbb{R}^{n\times d}$ и $Y \in \mathbb{R}^{m\times d}$. Также предлагалось сравнить результаты и скорость работы реализаций со стандартной реализацией \\ \lstinline$scipy.spatial.distance.cdist$.

В невекторизованном решении данной задачи требуемая матрица вычисляется с помощью двух вложенных циклов по объектам первой и второй выборки (норма разности между векторами также вычисляется в цикле). Векторизованное решение основывется на использовании {\it broadcasting} — в каждую из выборок добавляется новая ось на свое место, после чего вычисляется норма их разности по третьей оси: \lstinline$np.linalg.norm((x.T)[:, :, None] - (y.T)[:, None, :], axis=0)$. В функциональном решении требуемая матрица строится с помощью {\it list comprehension}.

Время работы для $(d, n, m) = (2, 5, 10)$ усреднялось по 1000 запусков для всех методов. Время работы для $(d, n, m) = (30, 100, 50)$ усреднялось по 100 запускам для всех методов. В последнем же эксперименте время работы для всех методов, кроме невекторизованного усреднялось по 10 запускам, а для невекторизованного — по 2. Результаты экспериментов приведены в таблице \ref{prb_7}.

	\begin{table}[t]
		\begin{center}
		\begin{tabular}{| c | c | c  !{\vrule width 1.2pt} c | c | c | c|}
			\hline
			\multicolumn{3}{ | c  !{\vrule width 1.2pt}  }{Параметры задачи}&
			\multicolumn{4}{   c |  }{Время работы}\\
			\hline
			$d$ & $n$ & $m$
			&
			\begin{tabular}{c} 
			Невект.\\ 
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.
			\\ 
			реализация
			\end{tabular}
			& 
			\begin{tabular}{c} 
			Станд.
			\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$2$ & $5$ & $10$ & 230 $\mu$s& 20.5 $\mu$s & 577 $\mu$s & 26.1 $\mu$s \\
			\hline 
			$30$ & $100$ & $50$ & 149 ms&  470 $\mu$s & 48.6 ms & 178 $\mu$s \\
			\hline 
			$100$ & $500$ & $1000$ & 49 s & 478 ms & 4.94 s & 43.5 ms \\
			\hline
		\end{tabular}
		\end{center}
		\caption{Результаты экспериментов по седьмой задаче}
		\label{prb_7}
	\end{table}

\subsection{Задача 8}

	\hspace{0.6cm}В этой задаче требовалось вычислить значения плотности многомерного распределения $\mathcal N(m, cov)$, где $m \in \mathbb{R}^{d}$, $cov \in \mathbb{R}^{d \times d}$ в данных точках $X \in \mathbb{R}^{n \times d}$. Также предлагалось сравнить результаты и скорость работы реализаций со стандартной реализацией \lstinline$scipy.stats.multivariate_normal(m, C).logpdf(X)$.  
	
	В невекторизованном решении плотность подсчитывается для каждой точки в цикле. При этом произведение матриц реализовано с помощью вложенных циклов. В векторизованном решении в формулу для плотности нормального распределения в данной точке $x$ вместо одной точки подставляется матрица $X$. В качестве ответа возвращается диагональ полученной таким образом матрицы. В функциональном решении вектор плотностей строится так же, как и в невекторизованном варианте, только вместо циклов используется {\it list comprehension}, и для умножения матриц используется \lstinline$numpy.dot()$.
	
	В экспериментах для $(d, n) = (30, 50)$ результаты усреднялись по $1000$ запускам для всех реализаций, кроме невекторизрванной, и по $100$ запускам для невекторизованной. В экспериментах для $(d, n) = (300, 100)$ результаты усреднялись по $100$ запускам для всех реализаций, кроме невекторизрванной, и по $2$ запускам для невекторизованной.  Наконец, для $(d, n) = (1000, 1000)$ результаты усреднялись по $10$ запускам для всех реализаций, кроме невекторизрванной, а для невекторизованной реализации эксперименты не проводились (время ее работы слишком велико).  Результаты экспериментов приведены в таблице \ref{prb_8}.
	
	\begin{table}[h]
		\begin{center}
		\begin{tabular}{| c |c  !{\vrule width 1.2pt} c | c | c | c |}
			\hline
			\multicolumn{2}{ | c  !{\vrule width 1.2pt}  }{Параметры задачи}&
			\multicolumn{4}{   c |  }{Время работы}\\
			\hline
			$d$ & $n$
			&
			\begin{tabular}{c} 
			Невект.\\ 
			реализация
			\end{tabular}
			 & 
			\begin{tabular}{c} 
			Вект.\\ 
			реализация
			\end{tabular} 
			& 
			\begin{tabular}{c} 
			Функ.
			\\ 
			реализация
			\end{tabular}
			&
			\begin{tabular}{c} 
			Станд.
			\\ 
			реализация
			\end{tabular}
			\\
			\noalign{\hrule height 1.2pt}
			$30$ & $50$ & 30.7 ms & 151 $\mu$s & 952 $\mu$s & 381 $\mu$s\\
			\hline 
			$300$ & $100$ & 5.65 s&  5.08 ms & 12.1 ms & 16.2 ms\\
			\hline 
			$1000$ & $1000$ & — &  197 ms &  451 ms & 320 ms\\
			\hline
		\end{tabular}
		\end{center}
		\caption{Результаты экспериментов по восьмой задаче}
		\label{prb_8}
	\end{table}
	
\pagebreak
\section{Выводы}

\hspace{0.6cm}В данной работе было произведено сравнение трех подходов к написанию программ на \lstinline$Python$ — векторизованного, невекторизованного, и в стиле функционального программирования. %В результате можно дать следующие практические рекомендации: практически всегда, когда это возможно, следует использовать векторизованный подход. 

Векторизованное решение проиграло невекторизованному только в одном эксперименте — в шестой задаче на данных наименьшего размера. Результат этого эксперимента можно объяснить тем, что предложенное мной векторизованное решение данной задачи имеет высокую сложность (см. листинг \ref{lst_vec_6}), и поэтому на данных маленьких объемов более простая невекторизованная реализация выигрывает. 

На данных средних и больших объемов векторизованная реализация во всех экспериментах существенно выигрывает у невекторизованной. 

Функциональная реализация оказалась эффективнее векторизованной в четырех экспериментах — в первом эксперименте шестой задачи и во всех экспериментах пятой задачи. Объяснения результатов первого эксперимента шестой задачи были даны выше. Что же касается пятой задачи, разница между функциональным и векторизованным решением для нее заключалась в способе подсчета взвешенного среднего между каналами. По всей видимости, метод \lstinline$numpy.average()$ менее эффективен, чем \lstinline$reduce()$, если требуется посчитать среднее небольшого количества точек. 

Таким образом, на практике всегда лучше по возможности использовать векторизованную реализацию. 



\end{document}